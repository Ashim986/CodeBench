---
phase: 01-foundation-bug-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyStructureCanvasView.swift
  - CodeBench/CodeBench/DataJourney/Models/DataJourneyModels.swift
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyHeapView.swift
autonomous: true
requirements: [REQ-F01, REQ-F02]

must_haves:
  truths:
    - "Graph nodes have stable IDs across re-layouts -- SwiftUI animates position changes instead of destroying/recreating nodes"
    - "Tree edges have stable IDs -- no flickering during step transitions"
    - "Trie nodes use existing trieNodeId as identity -- not UUID()"
    - "NamedTraceList uses list name as identity -- linked list group views do not flicker"
    - "DataJourneyEvent has stable identity for ForEach usage"
    - "Zero `let id = UUID()` patterns remain in any Identifiable layout/model struct"
    - "Layout computation for graphs runs once per data change, not on every SwiftUI body evaluation"
    - "Layout computation for trees runs once per data change, not on every render"
    - "Layout computation for tries runs once per data change, not on every render"
    - "Step playback maintains smooth animation -- no force simulation in body"
    - "Visualizations with more than 40 nodes show only the first 40 with an '...and N more' indicator"
  artifacts:
    - path: "CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift"
      provides: "Graph visualization with stable node/edge IDs and memoized layout"
      contains: "onChange(of:"
    - path: "CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift"
      provides: "Tree visualization with stable edge IDs and memoized layout"
      contains: "onChange(of:"
    - path: "CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift"
      provides: "Trie visualization with stable node/edge IDs and memoized layout"
      contains: "onChange(of:"
    - path: "CodeBench/CodeBench/DataJourney/Views/DataJourneyStructureCanvasView.swift"
      provides: "NamedTraceList with stable name-based ID"
    - path: "CodeBench/CodeBench/DataJourney/Models/DataJourneyModels.swift"
      provides: "DataJourneyEvent with stable composite ID"
  key_links:
    - from: "GraphLayout.Node.id"
      to: "ForEach in DataJourneyGraphView"
      via: "Identifiable protocol -- SwiftUI uses id to track node identity across renders"
      pattern: "id: \"node-"
    - from: "TraceTreeLayout.Edge.id"
      to: "ForEach in DataJourneyTreeGraphView"
      via: "Identifiable protocol -- stable edge IDs enable animation"
      pattern: "id: \"tree-edge-"
    - from: "@State private var cachedLayout"
      to: "onChange(of: adjacency)"
      via: "Layout recomputation triggered by data change, not body evaluation"
      pattern: "cachedLayout"
---

<objective>
Fix all UUID() identity instability in layout/model structs and memoize layout computation so it runs once per data change instead of every render.

Purpose: These are the two P0 bugs blocking all animation work. UUID identity causes SwiftUI to destroy and recreate nodes instead of animating them. Layout-in-body causes 50-iteration force simulations on every render, dropping frames.
Output: All layout structs use stable composite IDs. Layout computation cached in @State with onChange recomputation.
</objective>

<execution_context>
@/Users/ashimdahal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashimdahal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bug-fixes/01-RESEARCH.md
@CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift
@CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift
@CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift
@CodeBench/CodeBench/DataJourney/Views/DataJourneyStructureCanvasView.swift
@CodeBench/CodeBench/DataJourney/Models/DataJourneyModels.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace all UUID() identity with stable composite IDs</name>
  <files>
    CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyStructureCanvasView.swift,
    CodeBench/CodeBench/DataJourney/Models/DataJourneyModels.swift
  </files>
  <action>
Find and replace every `let id = UUID()` in Identifiable structs with stable composite string IDs. The research identified 7 UUID() sites plus NamedTraceList and DataJourneyEvent. Apply these specific fixes:

**GraphLayout.Node** (DataJourneyGraphView.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site, pass `id: "node-\(index)"` where index is the graph node index
- Per user decision: "Graph nodes: value + index composite" -- use `"node-\(index)-val\(value)"` if value is available, otherwise `"node-\(index)"`

**GraphLayout.Edge** (DataJourneyGraphView.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site, for undirected graphs: `id: "edge-\(min(index, neighbor))-\(max(index, neighbor))"`
- For directed graphs: `id: "edge-\(index)-\(neighbor)"`
- Maintain the existing `if isUndirected, neighbor < index { continue }` guard

**TraceTreeLayout.Edge** (DataJourneyTreeGraphView.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site: `id: "tree-edge-\(node.id)-\(childId)"` where node.id comes from TraceTreeNode
- Note: TraceTreeLayout.Node already uses stable `id: String` from TraceTreeNode -- confirm and leave as-is

**TrieLayout.LayoutNode** (DataJourneyTrieGraphView.swift):
- Change `let id = UUID()` to `let id: String`
- Per user decision: "Trie nodes: use existing trieNodeId string already stored but currently ignored"
- At construction site: `id: node.id` (from TraceTrieNode.id which is already stable)
- Remove the separate `trieNodeId` field if it becomes redundant with `id`

**TrieLayout.LayoutEdge** (DataJourneyTrieGraphView.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site: `id: "trie-edge-\(nodeId)-\(childId)"`

**NamedTraceList** (DataJourneyStructureCanvasView.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site: `id: name` (list name is unique within a group)

**DataJourneyEvent** (DataJourneyModels.swift):
- Change `let id = UUID()` to `let id: String`
- At construction site in `from(json:)`: use `"event-\(kind.rawValue)-\(line ?? 0)-\(label ?? "unlabeled")"` or a sequential index passed from the caller
- If events are used in ForEach (check DataJourneyVariableTimeline), ensure the composite ID is unique. If multiple events can share the same kind+line+label, append a sequence number.

After all replacements:
- Run `grep -rn "let id = UUID()" CodeBench/CodeBench/DataJourney/` to confirm ZERO matches remain
- Run `grep -rn "let id = UUID()" CodeBench/CodeBench/` to confirm ZERO matches in the entire app

CAUTION -- Pitfall from research:
- Edge ID collisions in undirected graphs: use min/max normalization
- DataJourneyEvent: if events are only created once and stored, sequential index is safest
  </action>
  <verify>
1. `grep -rn "let id = UUID()" CodeBench/CodeBench/DataJourney/` returns zero results
2. `grep -rn "let id = UUID()" CodeBench/CodeBench/` returns zero results
3. Each replaced struct still conforms to Identifiable (id property is String, not UUID)
4. All ForEach usages of these types compile correctly (String id works with ForEach)
  </verify>
  <done>Zero `let id = UUID()` patterns remain in any Identifiable struct. All layout/model structs use stable composite string IDs derived from data model properties. Graph nodes use index-based IDs, tree edges use parent-child IDs, trie nodes use trieNodeId, linked list groups use name, events use composite or sequential IDs.</done>
</task>

<task type="auto">
  <name>Task 2: Memoize layout computation in Graph, Tree, and Trie views</name>
  <files>
    CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift
  </files>
  <action>
Extract layout computation from SwiftUI `body` into `@State` cached properties with `onChange` recomputation. Currently, layout structs (GraphLayout, TraceTreeLayout, TrieLayout) are created directly inside `body`, causing expensive computation on every render.

**DataJourneyGraphView.swift -- GraphLayout memoization:**
1. Add `@State private var cachedLayout: GraphLayout?` property
2. Create a private helper: `private func makeLayout() -> GraphLayout { GraphLayout(adjacency: adjacency, size: compactSize, nodeSize: nodeSize) }` (match existing constructor parameters)
3. In `body`, use `let layout = cachedLayout ?? makeLayout()` instead of creating GraphLayout inline
4. Add `.onAppear { cachedLayout = makeLayout() }` to populate on first render
5. Add `.onChange(of: adjacency) { _, _ in cachedLayout = makeLayout() }` to recompute when data changes
6. If other properties affect layout (nodeSize, graph dimensions), add onChange for those too
7. Use the TWO-parameter onChange form: `onChange(of:) { oldValue, newValue in }` (iOS 17+ syntax; old single-parameter form is deprecated)

CAUTION -- @State initializer trap from research: Do NOT use `@State private var cachedLayout = GraphLayout(...)`. The initializer expression evaluates every body call even though SwiftUI only uses the first result. Initialize as nil, populate in onAppear.

**DataJourneyTreeGraphView.swift -- TraceTreeLayout memoization:**
1. Add `@State private var cachedTreeLayout: TraceTreeLayout?`
2. Create helper: `private func makeTreeLayout() -> TraceTreeLayout { TraceTreeLayout(tree: tree, nodeSize: nodeSize, levelSpacing: levelSpacing) }` (match existing params)
3. In body, use `let layout = cachedTreeLayout ?? makeTreeLayout()`
4. Add `.onAppear { cachedTreeLayout = makeTreeLayout() }`
5. Add `.onChange(of: tree) { _, _ in cachedTreeLayout = makeTreeLayout() }` -- requires TraceTree to conform to Equatable for onChange. If not already Equatable, add conformance (compare by node count + root id, or use a hash).
6. If TraceTree cannot easily be Equatable, use a proxy: store `@State private var lastTreeHash: Int = 0` and compare tree.hashValue in body, recomputing only when changed.

**DataJourneyTrieGraphView.swift -- TrieLayout memoization:**
1. Add `@State private var cachedTrieLayout: TrieLayout?`
2. Create helper matching existing TrieLayout constructor
3. Apply same onAppear + onChange pattern
4. Trie data comes from TraceTrie -- add Equatable or use proxy hash

**All layout types should use the same caching pattern per user decision:** "All layout types (graph, tree, trie) use the same caching pattern for consistency."

Pattern for all three:
```swift
@State private var cachedLayout: LayoutType?

var body: some View {
    let layout = cachedLayout ?? makeLayout()
    // ... render using layout ...
    .onAppear {
        cachedLayout = makeLayout()
    }
    .onChange(of: dataProperty) { _, _ in
        cachedLayout = makeLayout()
    }
}

private func makeLayout() -> LayoutType {
    LayoutType(/* existing params */)
}
```

Per user decision: "Simple layout memoization: compute once per data change, store in @State. In-memory only. No debug overlay for cache stats."
  </action>
  <verify>
1. `grep -n "GraphLayout(" CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift` shows layout creation only in makeLayout() and onAppear/onChange, NOT directly in body
2. `grep -n "TraceTreeLayout(" CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift` shows layout creation only in helper/onAppear/onChange
3. `grep -n "TrieLayout\|buildLayout" CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift` shows layout creation only in helper/onAppear/onChange
4. `grep -n "cachedLayout\|cachedTreeLayout\|cachedTrieLayout" CodeBench/CodeBench/DataJourney/Views/` shows @State cached properties in all three files
5. `grep -n "onChange(of:" CodeBench/CodeBench/DataJourney/Views/DataJourney{Graph,TreeGraph,TrieGraph}View.swift` shows onChange handlers in all three
  </verify>
  <done>Layout computation runs once per data change in all three visualization views. GraphLayout, TraceTreeLayout, and TrieLayout are cached in @State and recomputed only via onChange when underlying data changes. No layout constructors are called directly inside body. All three views use the same consistent caching pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Enforce 40-node hard limit with truncation indicator</name>
  <files>
    CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyTrieGraphView.swift,
    CodeBench/CodeBench/DataJourney/Views/DataJourneyHeapView.swift
  </files>
  <action>
Implement a hard limit of 40 nodes for all graph-like visualizations. When node count exceeds 40, show only the first 40 nodes and append a visual "...and N more" indicator. This is a locked user decision: "Hard limit of 40 nodes for visualization -- fixed, not configurable. Beyond 40: show first 40 nodes with '...and N more' indicator."

**Shared constant:**
Add a private constant `private let maxVisualizationNodes = 40` to each view file (or a shared constants location if one exists).

**DataJourneyGraphView.swift -- Graph truncation:**
1. In the `makeLayout()` helper (created in Task 2), BEFORE building the GraphLayout, check node count:
   ```swift
   let truncatedAdjacency: [[Int]]
   let isTruncated: Bool
   if adjacency.count > maxVisualizationNodes {
       truncatedAdjacency = Array(adjacency.prefix(maxVisualizationNodes))
       // Filter edges to only reference nodes within the first 40
       truncatedAdjacency = truncatedAdjacency.map { neighbors in
           neighbors.filter { $0 < maxVisualizationNodes }
       }
       isTruncated = true
   } else {
       truncatedAdjacency = adjacency
       isTruncated = false
   }
   ```
2. Pass `truncatedAdjacency` to the GraphLayout constructor instead of `adjacency`.
3. Store `isTruncated` and the overflow count in @State: `@State private var overflowNodeCount = 0`
4. In the view body, when `overflowNodeCount > 0`, overlay a Text label at the bottom of the graph canvas:
   ```swift
   if overflowNodeCount > 0 {
       Text("...and \(overflowNodeCount) more")
           .font(theme.typography.caption)  // Will use DS token after Plan 03
           .foregroundStyle(.secondary)
           .padding(.top, 4)
   }
   ```

**DataJourneyTreeGraphView.swift -- Tree truncation:**
1. In `makeTreeLayout()`, perform a BFS/level-order traversal of the tree and keep only the first 40 nodes encountered. This preserves tree structure from root downward.
2. For each excluded subtree root, mark the parent edge as truncated (or simply omit children beyond the limit).
3. Add the "...and N more" indicator when truncation occurs.

**DataJourneyTrieGraphView.swift -- Trie truncation:**
1. In the trie layout builder, perform a BFS of trie nodes and keep only the first 40.
2. Truncate deeper branches, preserving upper levels of the trie.
3. Add "...and N more" indicator.

**DataJourneyHeapView.swift -- Heap truncation:**
1. If heap array has more than 40 elements, slice to first 40.
2. Add "...and N more" indicator below the heap visualization.

The "...and N more" label should be a consistent pattern across all views: a small caption-styled text below the visualization canvas area.

Per user decision: "No complex caching infrastructure needed -- max ~40 nodes makes computation trivial."
  </action>
  <verify>
1. In each of the 4 view files, `grep -n "maxVisualizationNodes\|40" {file}` shows the truncation constant and logic
2. In each view file, `grep -n "and.*more" {file}` shows the overflow indicator text
3. Manually verify: if a test graph with 50 nodes is passed, only 40 render and "...and 10 more" appears
  </verify>
  <done>All graph-like visualizations (graph, tree, trie, heap) enforce a hard 40-node limit. When exceeded, only the first 40 nodes are displayed with a "...and N more" text indicator. Truncation happens before layout construction, keeping layout computation trivial.</done>
</task>

</tasks>

<verification>
1. `grep -rn "let id = UUID()" CodeBench/CodeBench/` returns zero results -- all UUID identity eliminated
2. Layout constructors appear only inside makeLayout helpers and onAppear/onChange, never in body
3. All three graph/tree/trie views have @State cached layout + onChange recomputation
4. NamedTraceList uses name-based ID
5. DataJourneyEvent uses stable composite ID
6. Xcode project builds without errors (all Identifiable conformances intact)
7. Graph, tree, trie, and heap views enforce 40-node hard limit with "...and N more" indicator when exceeded
</verification>

<success_criteria>
- Zero `let id = UUID()` in any Identifiable struct across the entire CodeBench app
- GraphLayout, TraceTreeLayout, and TrieLayout created in makeLayout() helpers, not inline in body
- All three views use @State + onAppear + onChange pattern for layout caching
- Step playback on graph/tree visualizations shows smooth animation (no node destruction/recreation)
- Visualizations with >40 nodes display only the first 40 with a truncation indicator
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bug-fixes/01-02-SUMMARY.md`
</output>
