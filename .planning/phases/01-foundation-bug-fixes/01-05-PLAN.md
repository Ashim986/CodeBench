---
phase: 01-foundation-bug-fixes
plan: 05
type: execute
wave: 3
depends_on: [01-02, 01-03, 01-04]
files_modified:
  - CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift
  - .swiftlint.yml
autonomous: false
requirements: [REQ-F01, REQ-F02]

must_haves:
  truths:
    - "A debug-only test view exists that rapidly cycles through step transitions for all structure types"
    - "SwiftLint rule flags any new `let id = UUID()` in Identifiable types -- regression prevented"
    - "Grep-based verification confirms zero hardcoded color/font/size values in visualization code"
    - "Visual confirmation: graph nodes animate smoothly without flickering during step playback"
    - "Visual confirmation: tree/trie visualizations render without frame drops"
  artifacts:
    - path: "CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift"
      provides: "Debug-only test view with rapid step transitions for all structure types"
      contains: "#if DEBUG"
    - path: ".swiftlint.yml"
      provides: "SwiftLint configuration with custom UUID() regression guard rule"
      contains: "no_uuid_identifiable"
  key_links:
    - from: "DataJourneyDebugTestHarness"
      to: "DataJourneyGraphView, DataJourneyTreeGraphView, DataJourneyTrieGraphView"
      via: "Embeds all visualization types with synthetic data and auto-advancing step timer"
      pattern: "Timer.publish"
---

<objective>
Build a debug-only test harness for visual verification, add SwiftLint regression guard for UUID(), and run comprehensive grep-based verification.

Purpose: Ensure all fixes are verifiable and regressions are prevented. The test harness enables rapid visual verification of smooth animations across all data structure types. The SwiftLint rule prevents re-introduction of UUID() identity. The grep check confirms zero hardcoded styling.
Output: Debug test view, SwiftLint config, verification results.
</objective>

<execution_context>
@/Users/ashimdahal/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ashimdahal/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-bug-fixes/01-RESEARCH.md
@.planning/phases/01-foundation-bug-fixes/01-02-SUMMARY.md
@.planning/phases/01-foundation-bug-fixes/01-03-SUMMARY.md
@.planning/phases/01-foundation-bug-fixes/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debug test harness and SwiftLint UUID regression rule</name>
  <files>
    CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift,
    .swiftlint.yml
  </files>
  <action>
**Part A: Debug Test Harness**

Create `CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift` wrapped in `#if DEBUG` / `#endif`. This view enables rapid visual verification of all visualization types with auto-advancing step transitions.

The view should:
1. Be wrapped entirely in `#if DEBUG` / `#endif` -- zero code in production builds
2. Import LeetPulseDesignSystem and SwiftUI
3. Create synthetic test data for each structure type:
   - **Array:** `[3, 1, 4, 1, 5, 9]` with 4-5 step events showing element changes
   - **Linked list:** 5-node list with step events showing pointer traversal
   - **Binary tree:** 7-node tree with step events showing node visits (inorder traversal)
   - **Graph:** 6-node adjacency list with step events showing BFS/DFS visited nodes
   - **Trie:** 3-word trie ("cat", "car", "cap") with step events showing insertions
   - **Matrix:** 3x3 grid with step events showing cell updates
   - **Heap:** 7-element min-heap with step events showing heapify
   - **String:** "racecar" with step events showing palindrome check pointers
4. Display all structure types in a vertical ScrollView
5. Use a `Timer.publish(every: 0.3)` to auto-advance through step events rapidly (faster than normal playback to stress-test animations)
6. Include a "Reset" button to restart the cycle
7. Include a step counter label showing current step / total steps

Per user decision: "Dedicated debug-only test view (#if DEBUG) with rapid step transitions across all structure types."

The test data does not need to be real algorithm traces -- synthetic data that exercises each renderer is sufficient.

**Part B: SwiftLint Configuration**

Create `.swiftlint.yml` at the project root with a custom rule to flag `UUID()` in Identifiable types:

```yaml
# .swiftlint.yml
custom_rules:
  no_uuid_identifiable:
    name: "No UUID() in Identifiable"
    regex: 'let id\s*=\s*UUID\(\)'
    message: "Use stable composite IDs instead of UUID() in Identifiable types. See REQ-F01."
    severity: error
```

Also add basic configuration:
- `included:` paths for CodeBench source
- `excluded:` paths for build artifacts, .build, TestCaseEvaluator
- Keep rules minimal -- this is not a comprehensive lint setup, just the UUID regression guard

Per user decision: "SwiftLint rule to flag UUID() in Identifiable types -- prevents regression."

**Part C: Grep-based Verification**

Run these verification commands and document results:

```bash
# 1. Zero UUID() identity in layout/model structs
grep -rn "let id = UUID()" CodeBench/CodeBench/

# 2. Zero hardcoded Color literals in visualization views (except VizTypography and Color.clear)
grep -rn "Color\.\(red\|green\|blue\|yellow\|orange\|gray\|white\|black\)" CodeBench/CodeBench/DataJourney/Views/ | grep -v VizTypography | grep -v Color.clear

# 3. Zero hardcoded system font sizes in visualization views (except VizTypography)
grep -rn "\.system(size:" CodeBench/CodeBench/DataJourney/Views/ | grep -v VizTypography

# 4. All visualization files import DS
grep -rL "import LeetPulseDesignSystem" CodeBench/CodeBench/DataJourney/Views/*.swift | grep -v VizTypography

# 5. Layout computation not in body
grep -n "GraphLayout(" CodeBench/CodeBench/DataJourney/Views/DataJourneyGraphView.swift
grep -n "TraceTreeLayout(" CodeBench/CodeBench/DataJourney/Views/DataJourneyTreeGraphView.swift
```

All checks should pass (zero matches for checks 1-4, layout only in helpers for check 5). If any check fails, fix the issue before proceeding.

Per user decision: "Grep-based check to confirm zero hardcoded color/font/size values remain after DS migration."
  </action>
  <verify>
1. `test -f CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift` confirms test harness exists
2. `grep "#if DEBUG" CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift` confirms debug-only wrapping
3. `grep "Timer.publish" CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift` confirms auto-advancing timer
4. `test -f .swiftlint.yml` confirms SwiftLint config exists
5. `grep "no_uuid_identifiable" .swiftlint.yml` confirms custom UUID rule
6. All 5 grep verification checks pass with zero unexpected matches
  </verify>
  <done>Debug test harness created with synthetic data for all 8 structure types and auto-advancing timer. SwiftLint UUID regression guard configured. All grep-based verification checks pass -- zero hardcoded styling, zero UUID identity, layout not in body.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of Phase 1 fixes</name>
  <files>CodeBench/CodeBench/DataJourney/Views/DataJourneyDebugTestHarness.swift</files>
  <action>
Present the completed Phase 1 work for human verification. This checkpoint verifies:
1. LeetPulseDesignSystem integrated as SPM dependency
2. All UUID() identity replaced with stable composite IDs
3. Layout computation memoized (runs once per data change, not per render)
4. All visualization views use DS tokens (no hardcoded colors/fonts)
5. TestCaseEvaluator duplicate removed
6. Debug test harness created
7. SwiftLint UUID regression guard added
8. 40-node truncation limit enforced with "...and N more" indicator

Verification steps for the user:
1. Open the Xcode project: `open CodeBench/CodeBench.xcodeproj`
2. Build the project (Cmd+B) -- should compile without errors
3. Run the app in Simulator
4. Navigate to the debug test harness view (accessible from a debug menu or direct navigation in DEBUG builds)
5. Verify visual behavior:
   a. Graph nodes: Should animate position changes smoothly -- no flickering, no nodes disappearing and reappearing
   b. Tree visualization: Nodes should stay stable as step data changes -- edges should not flicker
   c. Trie visualization: Nodes should remain in place across step transitions
   d. All structure types: The auto-advancing timer should show smooth animations across all 8 types
6. Check theme: Toggle between light and dark mode in Simulator (Settings > Developer > Dark Appearance). All visualization colors should adapt.
7. Verify 60fps: Open Instruments (Product > Profile) with the Animation Hitches template. Run the debug test harness -- there should be no hitch warnings during rapid step transitions.
  </action>
  <verify>User confirms: "approved" if animations are smooth and theme switching works, or describes issues seen.</verify>
  <done>Human has visually verified that graph/tree/trie nodes animate smoothly without flickering, all DS colors render correctly in light and dark modes, and step playback maintains 60fps.</done>
</task>

</tasks>

<verification>
1. Debug test harness exists at DataJourneyDebugTestHarness.swift, wrapped in #if DEBUG
2. SwiftLint config at .swiftlint.yml with no_uuid_identifiable custom rule
3. Grep verification: zero UUID() in Identifiable structs, zero hardcoded Color/Font in viz views
4. Human visual verification: smooth animations, no flickering, theme switching works
5. 60fps confirmed via Instruments (no animation hitches during rapid step transitions)
</verification>

<success_criteria>
- Debug test harness renders all 8 structure types with auto-advancing steps
- SwiftLint rule catches `let id = UUID()` patterns (test by temporarily adding one)
- Visual confirmation: no identity flickering during step playback
- Visual confirmation: both light and dark theme work correctly
- All grep checks pass with zero unexpected matches
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-bug-fixes/01-05-SUMMARY.md`
</output>
